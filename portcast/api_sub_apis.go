/*
Container Tracking API

This documentation defines how the users can utilize the Portcast API to retrieve the latest Track and Trace Data for any container, bill of lading or booking across 100+ carriers and 2500+ ports across the globe.  What's changed in the version 2.0? Find out more about it [here](https://support.portcast.io/support/solutions/articles/151000074289-api-release-notes-april-2023-)!!

API version: 2.0
Contact: support@portcast.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package portcast

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type SubAPIsAPI interface {

	/*
	GetApiV1EtaBillOfLadingBookmarksTerminals Fetch terminal data by Bookmark ID

	Enhance your supply chain visibility by ingesting terminal-specific data. 

Once you upload your container into Portcast system, use the Bill of Lading Bookmark ID to fetch terminal data for that container. 

Refer to this [coverage sheet](https://docs.google.com/spreadsheets/d/1l7eA1brGaEZwhUS1_xwq1puyK35maPN0T-DWwNJvnhI/edit#gid=118367482) for a detailed overview of the supported fields and the latest terminal coverage.

To enable this add-on, contact us at support@portcast.io. 

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param bookmarkId Bill of Lading Bookmark ID
	@return ApiGetApiV1EtaBillOfLadingBookmarksTerminalsRequest
	*/
	GetApiV1EtaBillOfLadingBookmarksTerminals(ctx context.Context, bookmarkId string) ApiGetApiV1EtaBillOfLadingBookmarksTerminalsRequest

	// GetApiV1EtaBillOfLadingBookmarksTerminalsExecute executes the request
	//  @return PortTerminalAddOn
	GetApiV1EtaBillOfLadingBookmarksTerminalsExecute(r ApiGetApiV1EtaBillOfLadingBookmarksTerminalsRequest) (*PortTerminalAddOn, *http.Response, error)
}

// SubAPIsAPIService SubAPIsAPI service
type SubAPIsAPIService service

type ApiGetApiV1EtaBillOfLadingBookmarksTerminalsRequest struct {
	ctx context.Context
	ApiService SubAPIsAPI
	bookmarkId string
	xCustomer *string
	body *map[string]interface{}
}

// [Enterprise Customers] Customer Name to indicate which org to get tracking data from
func (r ApiGetApiV1EtaBillOfLadingBookmarksTerminalsRequest) XCustomer(xCustomer string) ApiGetApiV1EtaBillOfLadingBookmarksTerminalsRequest {
	r.xCustomer = &xCustomer
	return r
}

func (r ApiGetApiV1EtaBillOfLadingBookmarksTerminalsRequest) Body(body map[string]interface{}) ApiGetApiV1EtaBillOfLadingBookmarksTerminalsRequest {
	r.body = &body
	return r
}

func (r ApiGetApiV1EtaBillOfLadingBookmarksTerminalsRequest) Execute() (*PortTerminalAddOn, *http.Response, error) {
	return r.ApiService.GetApiV1EtaBillOfLadingBookmarksTerminalsExecute(r)
}

/*
GetApiV1EtaBillOfLadingBookmarksTerminals Fetch terminal data by Bookmark ID

Enhance your supply chain visibility by ingesting terminal-specific data. 

Once you upload your container into Portcast system, use the Bill of Lading Bookmark ID to fetch terminal data for that container. 

Refer to this [coverage sheet](https://docs.google.com/spreadsheets/d/1l7eA1brGaEZwhUS1_xwq1puyK35maPN0T-DWwNJvnhI/edit#gid=118367482) for a detailed overview of the supported fields and the latest terminal coverage.

To enable this add-on, contact us at support@portcast.io. 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bookmarkId Bill of Lading Bookmark ID
 @return ApiGetApiV1EtaBillOfLadingBookmarksTerminalsRequest
*/
func (a *SubAPIsAPIService) GetApiV1EtaBillOfLadingBookmarksTerminals(ctx context.Context, bookmarkId string) ApiGetApiV1EtaBillOfLadingBookmarksTerminalsRequest {
	return ApiGetApiV1EtaBillOfLadingBookmarksTerminalsRequest{
		ApiService: a,
		ctx: ctx,
		bookmarkId: bookmarkId,
	}
}

// Execute executes the request
//  @return PortTerminalAddOn
func (a *SubAPIsAPIService) GetApiV1EtaBillOfLadingBookmarksTerminalsExecute(r ApiGetApiV1EtaBillOfLadingBookmarksTerminalsRequest) (*PortTerminalAddOn, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PortTerminalAddOn
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAPIsAPIService.GetApiV1EtaBillOfLadingBookmarksTerminals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/eta/tracking/bill-of-lading-bookmarks/{bookmark_id}/import_export_plan"
	localVarPath = strings.Replace(localVarPath, "{"+"bookmark_id"+"}", url.PathEscape(parameterValueToString(r.bookmarkId, "bookmarkId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xCustomer != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "x-customer", r.xCustomer, "")
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-api-key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v GetApiV1EtaBillOfLadingBookmarksTerminals400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v PostEtaBillOfLadingBookmarks401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetApiV1EtaBillOfLadingBookmarksTerminals403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetApiV1EtaBillOfLadingBookmarksTerminals404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
